import re

###############################################################################

USTREAM_SWF_URL   = 'http://www.ustream.tv/flash/viewer.swf'
USTREAM_AMF_URL   = 'http://cdngw.ustream.tv/Viewer/getStream/1/%s.amf'

USTREAM_LIVE_URL  = 'https://www.ustream.tv/flash/live/1/%s'
USTREAM_REC_URL   = 'https://www.ustream.tv/recorded/%s'

USTREAM_KEY       = '8C8687A40DFFF62C23AAE5E021BD2BFE'
USTREAM_CH_JSON   = 'http://api.ustream.tv/json/channel/%s/getInfo?key=%s'
USTREAM_REC_JSON  = 'http://api.ustream.tv/json/video/%s/getInfo?key=%s'
USTREAM_RPIN      = 'rpin.020926383682605014'
USTREAM_RGW_URL   = 'http://rgw.ustream.tv/gateway.php'

RE_CHANNEL_ID     = Regex('Channel\sID\:\s+(\d+)')
RE_RTMP_URL       = Regex('(rtmp\:\/\/[^\x00]+)')
RE_STREAM_NAME    = Regex('streamName(?:\W+)([^\x00]+)')
RE_STATUS         = Regex('status(?:\W+)([^\x00]+)')

###############################################################################

# Test live URL for PMS: http://localhost:32400/system/services/url/lookup?url=http%3A//www.ustream.tv/channel/live-iss-stream
# Test recorded URL for PMS: http://localhost:32400/system/services/url/lookup?url=http%3A//www.ustream.tv/recorded/23088640
# API: http://api.ustream.tv/[html|json|xml|php]/[subject]/[subjectUID|scope]/[command]/[otherparams]/?page=[n]&limit=[l]&key=[devkey]    

###############################################################################
def MetadataObjectForURL(url):

  if '/recorded/' in url:
    # For recorded videos, the video ID should be in the URL...
    video_id = url[url.rfind('/')+1:]
    json = JSON.ObjectFromURL(USTREAM_REC_JSON % (video_id, USTREAM_KEY))
  else:
    # For live channels, look for a video ID in the HTML...
    html = HTTP.Request(url=url, cacheTime=3).content
    video_id = RE_CHANNEL_ID.search(html).group(1)
    json = JSON.ObjectFromURL(USTREAM_CH_JSON % (video_id, USTREAM_KEY))
  
  video = json['results']
  clip_url = video['embedTagSourceUrl']
  title = video['title']
  if video['status'] == 'offline':
    # Playback will fail if a live channel happens to be offline when played.  Log this.
    Log(title + ' is currently offline.')
  summary = StripHTML(video['description'])
  try:
    thumb = video['imageUrl']['medium']
  except:
    thumb = R('icon-default.png')

  # Log('Using clip URL: ' + clip_url)

  return VideoClipObject(
      url = clip_url,
      title = title,
      summary = summary,
      thumb = thumb
    )

###############################################################################
def MediaObjectsForURL(url):

  return [
     MediaObject(
         audio_channels = 2,
         parts = [PartObject(key=Callback(PlayVideo, url = url))]
     )
  ]
 
###############################################################################
@indirect
def PlayVideo(url):

  html = HTTP.Request(url=url, cacheTime=3).content
  video_id = RE_CHANNEL_ID.search(html).group(1)
  amf_url = (USTREAM_AMF_URL % video_id)
  amf_content = HTTP.Request(amf_url).content
  status = RE_STATUS.search(amf_content).group(1)

  if '/recorded/' in url:
    # Pre-recorded videos use a very different mechanism than the live stuff...
    try:
      r = HTTP.Request(clip_url, follow_redirects=False).content
    except Exception, e:
      if e.headers.has_key('Location'):
        swf_url = e.headers['Location']
    
    # These are the values that we'll eventually need to stick in an AMF POST...
    
    Log('videoId : ' + video_id)  
    Log('pageUrl : ' + swf_url)
    Log('rpin    : ' + USTREAM_RPIN)
    
    # ... however, this is not currently supported.
 
  else:
    amf_url = (USTREAM_AMF_URL % video_id)
    amf_content = HTTP.Request(amf_url).content
    status = RE_STATUS.search(amf_content).group(1)
    Log('Channel at ' + url + ' is: ' + status)

    if status != 'offline':
      rtmp_url = RE_RTMP_URL.search(amf_content).group(1)
      stream_name = RE_STREAM_NAME.search(amf_content).group(1)
      if 'flash' in rtmp_url:
        rtmp_url = rtmp_url + '/' + stream_name
        swf = None
      else:
        swf = USTREAM_SWF_URL
      return IndirectResponse(VideoClipObject, key = RTMPVideoURL(url=rtmp_url, clip=stream_name, swf_url=swf, live=True))
    else:
      return None

####################################################################################################

def NormalizeURL(url):
  return url

####################################################################################################

def StripHTML(stringToStrip,paragraphsToNewLines=False):
  # Srips HTML tags from a string
  if paragraphsToNewLines:
    stringToStrip = re.sub(r'<\s*/p>', r'\n\n', stringToStrip)
  stringToStrip = re.sub(r'<[^>]*>', r'', stringToStrip)
  return stringToStrip